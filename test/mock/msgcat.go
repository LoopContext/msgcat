// Code generated by MockGen. DO NOT EDIT.
// Source: msgcat.go

// Package mock_msgcat is a generated GoMock package.
package mock_msgcat

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	msgcat "github.com/loopcontext/msgcat"
	reflect "reflect"
)

// MockMessageCatalog is a mock of MessageCatalog interface
type MockMessageCatalog struct {
	ctrl     *gomock.Controller
	recorder *MockMessageCatalogMockRecorder
}

// MockMessageCatalogMockRecorder is the mock recorder for MockMessageCatalog
type MockMessageCatalogMockRecorder struct {
	mock *MockMessageCatalog
}

// NewMockMessageCatalog creates a new mock instance
func NewMockMessageCatalog(ctrl *gomock.Controller) *MockMessageCatalog {
	mock := &MockMessageCatalog{ctrl: ctrl}
	mock.recorder = &MockMessageCatalogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMessageCatalog) EXPECT() *MockMessageCatalogMockRecorder {
	return m.recorder
}

// LoadMessages mocks base method
func (m *MockMessageCatalog) LoadMessages(lang string, messages []msgcat.RawMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadMessages", lang, messages)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadMessages indicates an expected call of LoadMessages
func (mr *MockMessageCatalogMockRecorder) LoadMessages(lang, messages interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadMessages", reflect.TypeOf((*MockMessageCatalog)(nil).LoadMessages), lang, messages)
}

// GetMessageWithCtx mocks base method
func (m *MockMessageCatalog) GetMessageWithCtx(ctx context.Context, msgCode int, msgParams ...interface{}) *msgcat.Message {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, msgCode}
	for _, a := range msgParams {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetMessageWithCtx", varargs...)
	ret0, _ := ret[0].(*msgcat.Message)
	return ret0
}

// GetMessageWithCtx indicates an expected call of GetMessageWithCtx
func (mr *MockMessageCatalogMockRecorder) GetMessageWithCtx(ctx, msgCode interface{}, msgParams ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, msgCode}, msgParams...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMessageWithCtx", reflect.TypeOf((*MockMessageCatalog)(nil).GetMessageWithCtx), varargs...)
}

// WrapErrorWithCtx mocks base method
func (m *MockMessageCatalog) WrapErrorWithCtx(ctx context.Context, err error, msgCode int, msgParams ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, err, msgCode}
	for _, a := range msgParams {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WrapErrorWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WrapErrorWithCtx indicates an expected call of WrapErrorWithCtx
func (mr *MockMessageCatalogMockRecorder) WrapErrorWithCtx(ctx, err, msgCode interface{}, msgParams ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, err, msgCode}, msgParams...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WrapErrorWithCtx", reflect.TypeOf((*MockMessageCatalog)(nil).WrapErrorWithCtx), varargs...)
}

// GetErrorWithCtx mocks base method
func (m *MockMessageCatalog) GetErrorWithCtx(ctx context.Context, msgCode int, msgParams ...interface{}) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, msgCode}
	for _, a := range msgParams {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetErrorWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// GetErrorWithCtx indicates an expected call of GetErrorWithCtx
func (mr *MockMessageCatalogMockRecorder) GetErrorWithCtx(ctx, msgCode interface{}, msgParams ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, msgCode}, msgParams...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetErrorWithCtx", reflect.TypeOf((*MockMessageCatalog)(nil).GetErrorWithCtx), varargs...)
}
